<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catan board editor — index.html</title>
  <!-- use Flask's static helper; if you open file directly you can change this to "static/style.css" -->
  <link rel="stylesheet" href="static/style.css">
</head>
<body>
  <div class="app-outer">
    <div class="app">
      <div class="left panel">
        <h1>CATAN</h1>
        <div class="board-wrap" id="boardWrap">
          <!-- SVG board rendered by JS -->
          <svg id="boardSvg" width="760" height="620" viewBox="-380 -310 760 620"></svg>
        </div>
      </div>

      <div class="controls panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <strong>Tile inputs</strong>
            <div class="small">Edit each tile's resource + token number. Save to play.</div>
          </div>
          <div class="flex">
            <button id="saveBtn">Save to server and play</button>
            <button id="loadFromServer">Load from server</button>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <label class="small">Hex size</label>
          <input id="sizeInput" type="number" value="55" min="30" max="80" style="width:80px" />
        </div>

        <div class="tile-list panel" id="tileList"></div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="resetBtn">Reset empty</button>
          <button id="fillStd">Fill standard sample</button>
        </div>

        <div class="small" style="margin-top:6px">Saves are kept in server memory (a simple list inside <code>game.py</code>) — they are not persisted to disk. Use "Load from server" to retrieve the most recently saved board.</div>
      </div>
    </div>
  </div>

<script>
/* ---------- constants ---------- */
const TILE_COLORS = { wood:'#2f9e44', brick:'#c2410c', sheep:'#9ae6b4', wheat:'#f6e05e', ore:'#94a3b8', desert:'#d6c9a8', water:'#7dd3fc' };

const HARBOUR_POS = [
  {q:0.05,r:-2.65,type:'3:1'}, {q:1.65,r:-2.55,type:'brick'}, {q:2.55,r:-1.6,type:'3:1'},
  {q:2.6,r:0,type:'sheep'}, {q:0.95,r:1.65,type:'3:1'}, {q:-0.9,r:2.55,type:'wood'},
  {q:-2.55,r:2.55,type:'3:1'}, {q:-2.6,r:1,type:'wheat'}, {q:-1.7,r:-0.9,type:'ore'}
];

// SAMPLE board (19 tiles) — used by "Fill standard sample" button
const SAMPLE = [
  {type:'ore', number:10},{type:'sheep', number:2},{type:'wood', number:9},{type:'wheat', number:12},{type:'brick', number:6},
  {type:'sheep', number:4},{type:'brick', number:10},{type:'wheat', number:9},{type:'wood', number:11},{type:'desert', number:null},
  {type:'wood', number:3},{type:'ore', number:8},{type:'wood', number:8},{type:'ore', number:3},{type:'wheat', number:4},
  {type:'sheep', number:5},{type:'brick', number:5},{type:'wheat', number:6},{type:'sheep', number:11}
];

/* ---------- state ---------- */
let board = [];
let harbours = HARBOUR_POS.map(h => ({...h}));
let hexSize = 55;

// precompute axial lists (sorted to match expected indexing)
const LAND_AXIAL = (() => {
  const arr = generateAxialCoordsRadius(2).filter(c => Math.max(Math.abs(c.q), Math.abs(c.r), Math.abs(-c.q-c.r)) <= 2);
  arr.sort((a,b) => a.r - b.r || a.q - b.q);
  return arr;
})();
const WATER_AXIAL = generateAxialCoordsRadius(3).filter(c => Math.max(Math.abs(c.q), Math.abs(c.r), Math.abs(-c.q-c.r)) === 3);

/* ---------- DOM refs ---------- */
const svg = document.getElementById('boardSvg');
const tileList = document.getElementById('tileList');
const sizeInput = document.getElementById('sizeInput');

/* add harbour editor area below tile list */
const harbourHeading = document.createElement('strong');
harbourHeading.style.marginTop = '12px';
harbourHeading.textContent = 'Harbours';
document.querySelector('.controls').appendChild(harbourHeading);

const harbourList = document.createElement('div');
harbourList.className = 'tile-list panel';
document.querySelector('.controls').appendChild(harbourList);

/* ---------- event wiring ---------- */
sizeInput.addEventListener('change', () => { hexSize = parseInt(sizeInput.value) || 55; render(); });

document.getElementById('saveBtn').addEventListener('click', async () => {
  try {
    const res = await fetch('/api/board', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ board, harbours })
    });
    if (!res.ok) throw new Error(await res.text());
    alert('Saved to server');
  } catch (e) { alert('Save failed: ' + e.message); }
});

document.getElementById('loadFromServer').addEventListener('click', loadFromServer);
document.getElementById('resetBtn').addEventListener('click', () => { board = emptyBoard(); render(); rebuildInputs(); });
document.getElementById('fillStd').addEventListener('click', () => { board = SAMPLE.map(x => ({ ...x })); render(); rebuildInputs(); });

/* ---------- helpers & rendering ---------- */
function emptyBoard(){ return LAND_AXIAL.map(_ => ({ type:'', number:null })); }

function rebuildInputs(){
  tileList.innerHTML = '';
  board.forEach((tile,i) => {
    const row = document.createElement('div'); row.className = 'tile-row';
    const idx = document.createElement('div'); idx.innerHTML = `<strong>#${i+1}</strong>`; idx.style.width = '48px';
    const sel = document.createElement('select');
    ['','wood','brick','sheep','wheat','ore','desert'].forEach(t => {
      const o = document.createElement('option'); o.value = t; o.textContent = t || '---'; if (t === tile.type) o.selected = true;
      sel.appendChild(o);
    });
    sel.addEventListener('change', () => { board[i].type = sel.value; render(); });
    const num = document.createElement('input'); num.type = 'number'; num.min = 2; num.max = 12; num.style.width = '86px';
    num.value = tile.number ?? '';
    num.addEventListener('change', () => { const v = num.value; board[i].number = v === '' ? null : Number(v); render(); });
    row.append(idx, sel, num);
    tileList.appendChild(row);
  });

  // Harbour editor
  harbourList.innerHTML = '';
  harbours.forEach((h,i) => {
    const row = document.createElement('div'); row.className = 'tile-row';
    const lbl = document.createElement('div'); lbl.textContent = `H${i+1}`; lbl.style.width = '40px';
    const sel = document.createElement('select');
    ['3:1','wood','brick','sheep','wheat','ore'].forEach(t => {
      const o = document.createElement('option'); o.value = t; o.textContent = t; if (h.type === t) o.selected = true;
      sel.appendChild(o);
    });
    sel.addEventListener('change', () => { h.type = sel.value; render(); });
    row.append(lbl, sel);
    harbourList.appendChild(row);
  });
}

function focusTile(index){
  const el = document.querySelector(`#land-${index}`);
  if(!el) return;
  el.classList.add('flash');
  setTimeout(()=> el.classList.remove('flash'), 700);
}

function axialToPixel(q,r,size){ const w = Math.sqrt(3) * size; const x = w * (q + r/2); const y = (3/2) * size * r; return {x,y}; }
function polygonPoints(cx,cy,size){ const pts = []; for(let i = 0; i < 6; i++){ const a = Math.PI/180 * (60 * i - 30); pts.push(`${cx + size * Math.cos(a)},${cy + size * Math.sin(a)}`); } return pts.join(' '); }

function render(){
  const size = hexSize;
  svg.innerHTML = '';

  // draw water hexes
  WATER_AXIAL.forEach(ax => {
    const p = axialToPixel(ax.q, ax.r, size);
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points', polygonPoints(p.x, p.y, size));
    poly.setAttribute('fill', TILE_COLORS.water);
    poly.setAttribute('stroke', '#033657');
    poly.setAttribute('stroke-width', '2');
    svg.appendChild(poly);
  });

  // draw land hexes in LAND_AXIAL order (keeps index mapping stable)
  LAND_AXIAL.forEach((ax, i) => {
    const p = axialToPixel(ax.q, ax.r, size);
    const t = board[i] || { type:'', number:null };
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points', polygonPoints(p.x, p.y, size));
    poly.setAttribute('fill', TILE_COLORS[t.type] || '#0b1220');
    poly.setAttribute('stroke', '#071224');
    poly.setAttribute('stroke-width', '2');
    svg.appendChild(poly);

    // resource label
    const res = document.createElementNS('http://www.w3.org/2000/svg','text');
    res.setAttribute('x', p.x);
    res.setAttribute('y', p.y - size * 0.25);
    res.setAttribute('text-anchor', 'middle');
    res.setAttribute('dominant-baseline', 'middle');
    res.setAttribute('class', 'small');
    res.setAttribute('fill', '#071224');
    res.textContent = t.type ? t.type.toUpperCase() : '';
    svg.appendChild(res);

    // number token
    if (t.number != null && t.type !== 'desert' && t.number !== '') {
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('cx', p.x);
      circ.setAttribute('cy', p.y + size * 0.22);
      circ.setAttribute('r', size * 0.36);
      circ.setAttribute('fill', '#f6f7f9');
      circ.setAttribute('class', 'hex-token-circle');
      circ.setAttribute('stroke', '#071224');
      circ.setAttribute('stroke-width', '2');
      if (Number(t.number) === 6 || Number(t.number) === 8) circ.classList.add('hot');
      svg.appendChild(circ);

      const num = document.createElementNS('http://www.w3.org/2000/svg','text');
      num.setAttribute('x', p.x);
      num.setAttribute('y', p.y + size * 0.22 + 6);
      num.setAttribute('text-anchor', 'middle');
      num.setAttribute('class', 'hex-number');
      num.textContent = t.number;
      svg.appendChild(num);
    }

    // desert robber
    if (t.type === 'desert') {
      const rob = document.createElementNS('http://www.w3.org/2000/svg','text');
      rob.setAttribute('x', p.x);
      rob.setAttribute('y', p.y + size * 0.26 + 6);
      rob.setAttribute('text-anchor', 'middle');
      rob.setAttribute('fill', '#3b3b3b');
      rob.setAttribute('font-weight', '700');
      rob.textContent = 'Robber';
      svg.appendChild(rob);
    }

    // click to focus input
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    // wrap polygon and texts: for simplicity we used separate shapes above, but we still attach id to an empty group for flash target
    g.setAttribute('id', `land-${i}`);
    svg.appendChild(g);
  });

  // draw harbours as small circles with text
  harbours.forEach((h,i) => {
    // place harbour slightly outward from the water center so it's visible on the edge
    const p = axialToPixel(h.q, h.r, size * 1.05);
    const r = Math.max(10, size * 0.25);
    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('cx', p.x);
    circle.setAttribute('cy', p.y);
    circle.setAttribute('r', r);
    circle.setAttribute('fill', '#f8fafc');
    circle.setAttribute('stroke', '#04203a');
    circle.setAttribute('stroke-width', '1');
    svg.appendChild(circle);

    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', p.x);
    txt.setAttribute('y', p.y + 4);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('class', 'harbour-label');
    txt.textContent = h.type;
    svg.appendChild(txt);
  });
}

function generateAxialCoordsRadius(maxRadius){
  const coords = [];
  for(let r=-maxRadius; r<=maxRadius; r++){
    for(let q=-maxRadius; q<=maxRadius; q++){
      const s = -q - r;
      if(Math.max(Math.abs(q), Math.abs(r), Math.abs(s)) <= maxRadius) coords.push({q, r});
    }
  }
  return coords;
}

</script>

</body>
</html>







