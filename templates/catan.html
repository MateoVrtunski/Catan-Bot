<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catan ‚Äî Game</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    .app-outer{min-height:100vh;display:flex;align-items:flex-start;justify-content:flex-start;padding:20px;box-sizing:border-box;gap:16px}
    .board-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:12px;flex:1;overflow:auto}
    .controls{width:360px;display:flex;flex-direction:column;gap:10px}
    .player-card{
      padding:14px;
      border-radius:10px;
      background:rgba(255,255,255,0.06);
      margin-bottom:12px;
      font-size:15px;
      line-height:1.4;
    }

    .small{
      font-size:14px;
      color:#cfd8e3;
    }

    button{padding:8px 10px;border-radius:8px;border:0;background:#60a5fa;color:#04203a;cursor:pointer}
    .action-row{display:flex;gap:8px;align-items:center}
    .hex-token-circle,
    .hex-number,
    .robber {
    pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="app-outer">
    <div class="board-wrap">
      <svg id="boardSvg" width="900" height="700" viewBox="-380 -310 760 620"></svg>
    </div>

    <div class="controls panel">
      <strong>Players</strong>
      <div id="playersList"></div>

      <strong>Turn & Dice</strong>
      <div class="small" id="turnInfo">loading...</div>
      <div class="action-row">
        <input id="diceInput" type="number" min="2" max="12" style="width:90px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit" />
        <button id="rollBtn">Roll / Give</button>
      </div>

      <strong>Strategy Decision</strong>

      <div class="action-row">
        <select id="decisionPlayer" style="flex:1;padding:6px;border-radius:6px"></select>
        <button id="decisionBtn">Decision</button>
        <button id="robberDecisionBtn">Robber</button>
      </div>

      <strong>Actions</strong>
      <div class="action-row">
        <button id="actSettlement">Place Settlement</button>
        <button id="actRoad">Place Road</button>
        <button id="actCity">Build City</button>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="buyCard">Buy Dev Card</button>
        <button id="passBtn">Pass Turn</button>
        <button id="actRobber">Move Robber</button>
      </div>

      <hr style="margin:12px 0">

      <strong>Admin: Edit Resources</strong>
      <div class="small">Fix mistakes by setting or adjusting player resources.</div>

      <div class="action-row" style="margin-top:6px">
        <select id="resPlayer" style="flex:1;padding:6px;border-radius:6px">
        </select>
      </div>

      <div id="resEditor" style="display:grid;grid-template-columns:repeat(2,1fr);gap:6px;margin-top:8px">
        <!-- inputs injected by JS -->
      </div>

      <div class="action-row" style="margin-top:8px">
        <button id="resSetBtn">Set</button>
      </div>

      <div id="resMsg" class="small"></div>
      <div class="action-row">
        <select id="awardPlayer" style="flex:1;padding:6px;border-radius:6px"></select>
      </div>

      <div class="action-row">
        <button id="awardLongestRoad">Award Longest Road</button>
        <button id="awardLargestArmy">Award Largest Army</button>
      </div>

    </div>
  </div>

<script>
// ---------- helpers (same math as placement/index) ----------
function generateAxialCoordsRadius(maxRadius){
  const coords=[];
  for(let r=-maxRadius;r<=maxRadius;r++){
    for(let q=-maxRadius;q<=maxRadius;q++){
      const s=-q-r;
      if(Math.max(Math.abs(q),Math.abs(r),Math.abs(s))<=maxRadius) coords.push({q,r});
    }
  }
  return coords;
}
function axialToPixel(q,r,size){ const w=Math.sqrt(3)*size; const x=w*(q + r/2); const y=(3/2)*size*r; return {x,y}; }
function polygonPoints(cx,cy,size){ const pts=[]; for(let i=0;i<6;i++){ const a=Math.PI/180*(60*i-30); pts.push(`${cx+size*Math.cos(a)},${cy+size*Math.sin(a)}`);} return pts.join(' '); }

// ---------- state ----------
let BOARD = [], HARBOURS = [], PLAYERS = [], PLACEMENTS = [], ROADS = [];
let INTERSECTIONS = []; // computed on client too for interactions
let hexSize = 55;
let LAND_AXIAL = generateAxialCoordsRadius(2).filter(c=>Math.max(Math.abs(c.q),Math.abs(c.r),Math.abs(-c.q-c.r))<=2).sort((a,b)=>a.r-b.r||a.q-b.q);
let WATER_AXIAL = generateAxialCoordsRadius(3).filter(c=>Math.max(Math.abs(c.q),Math.abs(c.r),Math.abs(-c.q-c.r))===3);
let ROBBER_TILE = null;
let LONGEST_ROAD = null;
let LARGEST_ARMY = null;

let mode = null; // null | 'settlement' | 'road' | 'city'
let turn = 0; // current player index
let selectedIntersection = null;
let selectedEdge = null;

// DOM refs
const svg = document.getElementById('boardSvg');
const playersList = document.getElementById('playersList');
const turnInfo = document.getElementById('turnInfo');
const diceInput = document.getElementById('diceInput');

async function loadState(){
  const res = await fetch('/api/state');
  if(!res.ok) return alert('Failed to load game state');
  const data = await res.json();
  BOARD = Array.isArray(data.board)?data.board:[];
  HARBOURS = Array.isArray(data.harbours)?data.harbours:[];
  PLAYERS = Array.isArray(data.players)?data.players:[];
  PLACEMENTS = Array.isArray(data.placements)?data.placements:[];
  ROADS = Array.isArray(data.roads)?data.roads:[];
  INTERSECTIONS = Array.isArray(data.intersection)?data.intersection:[];
  ROBBER_TILE = data.robber_tile;
  LONGEST_ROAD = data.longest_road ?? null;
  LARGEST_ARMY = data.largest_army ?? null;

 
  draw();
  renderPlayers();
  renderTurnInfo();
  initResourceEditor();
  initDecisionPlayers();
  initAwardPlayers();
}



function draw(){
  svg.innerHTML = '';
  const size = hexSize;

  WATER_AXIAL.forEach(ax=>{
    const p = axialToPixel(ax.q,ax.r,size);
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points', polygonPoints(p.x,p.y,size));
    poly.setAttribute('fill', '#7dd3fc');
    poly.setAttribute('stroke','#033657'); poly.setAttribute('stroke-width','2');
    svg.appendChild(poly);
  });

  // harbours
  HARBOURS.forEach(h=>{
    const p = axialToPixel(h.q,h.r,size*1.05);
    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx',p.x); circ.setAttribute('cy',p.y); circ.setAttribute('r', Math.max(8,size*0.22));
    circ.setAttribute('fill','#f8fafc'); circ.setAttribute('stroke','#04203a'); circ.setAttribute('stroke-width','1');
    svg.appendChild(circ);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x',p.x); t.setAttribute('y',p.y+4); t.setAttribute('text-anchor','middle'); t.setAttribute('class','harbour-label');
    t.textContent = h.type; svg.appendChild(t);
  });

  // land tiles
  LAND_AXIAL.forEach((ax,i)=>{
    const p = axialToPixel(ax.q,ax.r,size);
    const tile = BOARD[i]||{};
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points', polygonPoints(p.x,p.y,size));
    poly.setAttribute('fill', tile.type ? ( { wood:'#2e8b57', brick:'#c2410c', sheep:'#9ae6b4', wheat:'#f6e05e', ore:'#94a3b8', desert:'#d6c9a8' }[tile.type] ) : '#0b1220');
    poly.setAttribute('stroke','#071224'); poly.setAttribute('stroke-width','2');
    svg.appendChild(poly);

    poly.addEventListener('click', async ()=>{
      if(mode !== 'robber') return;

      const res = await fetch('/api/robber', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ tile: i })
      });

      if(!res.ok){
        alert('Failed to move robber');
        return;
      }

      mode = null;
      await loadState();
    });

    if(tile.number){
    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx', p.x);
    circ.setAttribute('cy', p.y + size * 0.22);
    circ.setAttribute('r', size * 0.36);
    circ.setAttribute('fill', '#f6f7f9');
    circ.setAttribute('stroke', '#071224');
    circ.setAttribute('stroke-width', '2');
    circ.setAttribute('class', 'hex-token-circle');
    circ.style.pointerEvents = 'none';
    svg.appendChild(circ);

    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', p.x);
    txt.setAttribute('y', p.y + size * 0.22 + 6);
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('class', 'hex-number');
    txt.style.pointerEvents = 'none';
    txt.textContent = tile.number;
    svg.appendChild(txt);
    }
    

  });

  // roads
  ROADS.forEach(r=>{
    const a = INTERSECTIONS[r.a]; const b = INTERSECTIONS[r.b];
    if(!a||!b) return;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x); line.setAttribute('y1',a.y); line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
    line.setAttribute('stroke', PLAYERS[r.player] ? PLAYERS[r.player].color : '#000'); line.setAttribute('stroke-width', Math.max(4, size*0.08));
    line.setAttribute('stroke-linecap','round');
    svg.appendChild(line);
  });

  // intersections (settlements) and click handlers
  // intersections (settlements / cities) and click handlers
  INTERSECTIONS.forEach(iv=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${iv.x},${iv.y})`);
    g.style.cursor = 'pointer';

    let shape;

    // intersection id label
    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('y', -10);
    label.setAttribute('text-anchor','middle');
    label.setAttribute('font-size','10');
    label.setAttribute('fill','#111');
    label.textContent = iv.id;
    g.appendChild(label);

    if (iv.occupiedBy !== "None" && iv.building === "city") {
      // CITY ‚Üí 5-point star polygon
      shape = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const R = Math.max(12, hexSize * 0.28);
      const r = R * 0.45;
      let pts = "";
      for (let i = 0; i < 10; i++) {
        const angle = Math.PI / 180 * (i * 36 - 90);
        const rad = i % 2 === 0 ? R : r;
        pts += (Math.cos(angle) * rad) + "," + (Math.sin(angle) * rad) + " ";
      }
      shape.setAttribute("points", pts.trim());
    } else {
      // SETTLEMENT ‚Üí circle
      shape = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      shape.setAttribute("r", Math.max(6, hexSize * 0.12));
    }

    shape.setAttribute(
      "fill",
      iv.occupiedBy === "None"
        ? "#eef3f7"
        : (PLAYERS[iv.occupiedBy]?.color || "#000")
    );
    shape.setAttribute("stroke", "#04203a");
    shape.setAttribute("stroke-width", iv.occupiedBy === "None" ? 1 : 2);
    g.appendChild(shape);


    // click handler
    g.addEventListener('click', async (e)=>{
      e.stopPropagation();
      if(mode==='settlement'){
        // call API to place settlement for current player
        const playerIndex = turn;
        const res = await fetch('/api/build/settlement', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player: turn, intersection: iv.id })});
        if(!res.ok) { alert('Build failed: '+await res.text()); return; }
        // refresh state
        await loadState();
      } else if(mode==='road'){
        const opts = iv.neighbors || [];
        if(opts.length===0) return;
        const choices = opts.map(nid => `edge to ${nid}`).join('\\n');
        const pick = prompt(`Place road from intersection ${iv.id} to which neighbor?\\n${choices}\\nEnter neighbor id:`); 
        const nid = parseInt(pick);
        if(isNaN(nid)) return;
        const res2 = await fetch('/api/build/road', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player: turn, a: iv.id, b: nid })});
        if(!res2.ok) { alert('Road failed: '+await res2.text()); return; }
        await loadState();
      } else if(mode==='city'){
        if(iv.occupiedBy!==turn) { alert('You must own that settlement to upgrade'); return; }
        const res3 = await fetch('/api/build/city', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player: turn, intersection: iv.id })});
        if(!res3.ok) { alert('City failed: '+await res3.text()); return; }
        await loadState();
      } else {
        alert(`Intersection ${iv.id} ‚Äî adjacent tiles: ${iv.adjacentHexes.join(',')}`);
      }
    });

  svg.appendChild(g);
  });
  // ===== ROBBER (draw on top) =====
  // ===== ROBBER (draw on top) =====
  if (ROBBER_TILE !== null && LAND_AXIAL[ROBBER_TILE]) {
    const ax = LAND_AXIAL[ROBBER_TILE];
    const p = axialToPixel(ax.q, ax.r, hexSize);

    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class', 'robber');

    const body = document.createElementNS('http://www.w3.org/2000/svg','circle');
    body.setAttribute('cx', p.x);
    body.setAttribute('cy', p.y);
    body.setAttribute('r', hexSize * 0.45);
    body.setAttribute('fill', '#000');
    body.setAttribute('stroke', '#fff');
    body.setAttribute('stroke-width', '4');

    g.appendChild(body);
    svg.appendChild(g);
  }



}

function initAwardPlayers(){
  const sel = document.getElementById('awardPlayer');
  sel.innerHTML = '';
  PLAYERS.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i}: ${p.name}`;
    sel.appendChild(opt);
  });
}


// render players sidebar
function renderPlayers(){
  playersList.innerHTML = '';
  PLAYERS.forEach((p, idx)=>{
    const div = document.createElement('div'); div.className='player-card';
    div.style.borderLeft = `8px solid ${p.color||'#777'}`;
    const resources = (p.resources||{wood:0,brick:0,sheep:0,wheat:0,ore:0});
    const hasLongest = LONGEST_ROAD === idx ? " üõ£Ô∏è Longest Road" : "";
    const hasArmy = LARGEST_ARMY === idx ? " üõ°Ô∏è Largest Army" : "";
    const dev = p.dev_cards || {};
    div.innerHTML = `<div><strong>${p.name} ${idx===turn? '(current)':''}</strong></div>
      <div class="small">VP: ${p.victory_points || 0}</div>
      <div class="small">${hasLongest}${hasArmy}</div>
      <div class="small">Settlements: ${p.settlements_left} &nbsp; Cities: ${p.cities_left} &nbsp; Roads: ${p.roads_left}</div>
      <div class="small">
      Dev cards ‚Üí
      K:${dev.knight||0}
      M:${dev.monopoly||0}
      P:${dev.plenty||0}
      R:${dev.road||0}
      VP:${dev.point||0}
      </div>
      <div class="small">Wood:${resources.wood} Brick:${resources.brick} Sheep:${resources.sheep} Wheat:${resources.wheat} Ore:${resources.ore}</div>`;
    playersList.appendChild(div);
  });
}

function initDecisionPlayers(){
  const sel = document.getElementById('decisionPlayer');
  sel.innerHTML = '';
  PLAYERS.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i}: ${p.name}`;
    sel.appendChild(opt);
  });
}

// show turn info
function renderTurnInfo(){
  turnInfo.textContent = `Player ${turn+1}'s turn ‚Äî ${PLAYERS[turn] ? PLAYERS[turn].name : ''}`;
}

// button handlers
document.getElementById('rollBtn').addEventListener('click', async ()=>{
  const v = parseInt(diceInput.value);
  if(isNaN(v) || v<2 || v>12) return alert('Enter dice 2-12');
  const res = await fetch('/api/roll', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ dice: v })});
  if(!res.ok) { alert('Roll failed: '+await res.text()); return; }
  // reload state to show resource changes
  await loadState();
  alert('Resources distributed for roll ' + v);
});

document.getElementById('actSettlement').addEventListener('click', ()=>{ mode='settlement'; alert('Click an empty highlighted intersection to place settlement'); });
document.getElementById('actRoad').addEventListener('click', ()=>{ mode='road'; alert('Click an intersection you own (or adjacent) then choose neighbor id for road'); });
document.getElementById('actCity').addEventListener('click', ()=>{ mode='city'; alert('Click your settlement to upgrade to city'); });
document.getElementById('actRobber').addEventListener('click', ()=>{mode = 'robber';alert('Click a tile to move the robber');});


document.getElementById('passBtn').addEventListener('click', async ()=>{
  // advance turn on server if you track turn, otherwise client rotate
  turn = (turn + 1) % PLAYERS.length;
  await loadState();
  renderTurnInfo();
  alert('Turn passed ‚Äî next player should roll dice.');
});

document.getElementById('decisionBtn').addEventListener('click', async ()=>{
  const playerId = +document.getElementById('decisionPlayer').value;

  const res = await fetch('/api/decision/in_game', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ player: playerId })
  });

  if(!res.ok){
    alert('Decision failed');
    return;
  }

  const data = await res.json();

  if(data.decision === null){
    alert('No useful action available');
    return;
  }

  let msg = `Player ${playerId} decision:\n`;

  if(data.decision.city !== undefined){
    msg += `‚Ä¢ Build CITY at intersection ${data.decision.city}\n`;
  }

  if(data.decision.settlement !== undefined){
    msg += `‚Ä¢ Build SETTLEMENT at intersection ${data.decision.settlement}\n`;
  }

  if(data.decision.road !== undefined){
    msg += `‚Ä¢ Build ROAD toward intersection ${data.decision.road}\n`;
  }

  if(data.decision.card !== undefined){
    msg += `‚Ä¢ Buy CARD \n`;
  }

  if(data.trade && data.trade.i_need){
    msg += '\nSuggested trade:\n';
    msg += `Need: ${JSON.stringify(data.trade.i_need)}\n`;
    msg += `Give: ${JSON.stringify(data.trade.i_give)}`;
  }

  alert(msg);
});

document.getElementById('awardLongestRoad').onclick = async ()=>{
  const pid = +document.getElementById('awardPlayer').value;
  const res = await fetch('/api/award/longest_road',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ player: pid })
  });
  if(!res.ok) return alert('Failed');
  await loadState();
};

document.getElementById('awardLargestArmy').onclick = async ()=>{
  const pid = +document.getElementById('awardPlayer').value;
  const res = await fetch('/api/award/largest_army',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ player: pid })
  });
  if(!res.ok) return alert('Failed');
  await loadState();
};

document.getElementById('robberDecisionBtn').addEventListener('click', async ()=>{
  const playerId = +document.getElementById('decisionPlayer').value;

  const res = await fetch('/api/decision/robber', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ player: playerId })
  });

  if(!res.ok){
    alert('Robber decision failed');
    return;
  }

  const data = await res.json();

  if(data.decision === null){
    alert('No good robber move found');
    return;
  }

  const msg =
    `Robber suggestion for player ${playerId}:\n\n` +
    `‚Ä¢ Tile index: ${data.tile}\n` +
    `‚Ä¢ Resource: ${data.resource}\n` +
    `‚Ä¢ Number: ${data.number}\n\n` +
    `Click "Move Robber" and select this tile.`;

  alert(msg);
});


// ================= ADMIN RESOURCE EDITOR =================
const RESOURCE_KEYS = ["wood","brick","sheep","wheat","ore"];
const DEV_CARD_KEYS = [["knight", "Knight"],["monopoly", "Monopoly"],["plenty", "Card of Plenty"],["road", "Two Roads"],["point", "Victory Point Card"]];


function initResourceEditor(){
  const sel = document.getElementById('resPlayer');
  sel.innerHTML = '';
  PLAYERS.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${i}: ${p.name}`;
    sel.appendChild(opt);
  });

  const editor = document.getElementById('resEditor');
  editor.innerHTML = '';
  RESOURCE_KEYS.forEach(r=>{
    const wrap = document.createElement('div');
    wrap.innerHTML = `
      <label class="small">${r}</label>
      <input id="res_${r}" type="number" value="0"
        style="width:100%;padding:6px;border-radius:6px">
    `;
    editor.appendChild(wrap);
  });

  const vpWrap = document.createElement('div');
  vpWrap.innerHTML = `
    <label class="small">Victory Points</label>
    <input id="res_vp" type="number" value="0"
      style="width:100%;padding:6px;border-radius:6px">
  `;
  editor.appendChild(vpWrap);

  // ---- Development Cards ----
  DEV_CARD_KEYS.forEach(([key, label])=>{
    const wrap = document.createElement('div');
    wrap.innerHTML = `
      <label class="small">${label}</label>
      <input id="dev_${key}" type="number" value="0"
        style="width:100%;padding:6px;border-radius:6px">
    `;
    editor.appendChild(wrap);
  });

  sel.addEventListener('change', ()=>fillResInputs(+sel.value));
  if(PLAYERS.length) fillResInputs(0);

  document.getElementById('resSetBtn').onclick = (e)=>{
  e.preventDefault();
  applyRes();};

}

function fillResInputs(pid){
  const p = PLAYERS[pid] || {};
  const r = p.resources || {};
  RESOURCE_KEYS.forEach(k=>{
    const el = document.getElementById(`res_${k}`);
    if(el) el.value = r[k] || 0;
  });

  // victory points
  const vpEl = document.getElementById("res_vp");
  if(vpEl) vpEl.value = (p.victory_points !== undefined) ? p.victory_points : 0;

  // dev cards
  const d = p.dev_cards || {};
  DEV_CARD_KEYS.forEach(([key])=>{
    const el = document.getElementById(`dev_${key}`);
    if(el) el.value = d[key] || 0;
  });
}

function readResInputs(){
  const out = {};
  RESOURCE_KEYS.forEach(k=>{
    out[k] = parseInt(document.getElementById(`res_${k}`).value) || 0;
  });
  return out;
}

async function applyRes(){
  const pid = +document.getElementById('resPlayer').value;

  // resources
  const resources = {};
  RESOURCE_KEYS.forEach(k=>{
    resources[k] = Math.max(
      0,
      parseInt(document.getElementById(`res_${k}`).value) || 0
    );
  });

  // victory points
  const victory_points = Math.max(
    0,
    parseInt(document.getElementById("res_vp").value) || 0
  );

  // dev cards
  const dev_cards = {};
  DEV_CARD_KEYS.forEach(([key])=>{
    dev_cards[key] = Math.max(
      0,
      parseInt(document.getElementById(`dev_${key}`).value) || 0
    );
  });

  const res = await fetch('/api/set_resources',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({
      player: pid,
      resources,
      victory_points,
      dev_cards
    })
  });

  if(!res.ok){
    document.getElementById('resMsg').textContent = 'Update failed';
    return;
  }

  const j = await res.json();
  PLAYERS[pid] = j.player;
  renderPlayers();
  document.getElementById('resMsg').textContent = 'Updated';
}


// init
loadState();
</script>
</body>
</html>
